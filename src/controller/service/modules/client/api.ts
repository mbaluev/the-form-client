//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from 'axios';

export class AzureResourcesClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAzureSubscriptionsOfUser(
    tenantId: string,
    body: AzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<AzureSubscription[]> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/azure-resources/list/subscriptions';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAzureSubscriptionsOfUser(_response);
      });
  }

  protected processGetAzureSubscriptionsOfUser(
    response: AxiosResponse
  ): Promise<AzureSubscription[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<AzureSubscription[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AzureSubscription[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAzureResourceGroupsOfSubscription(
    tenantId: string,
    body: StringAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<AzureResourceGroup[]> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/azure-resources/list/resource-groups';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAzureResourceGroupsOfSubscription(_response);
      });
  }

  protected processGetAzureResourceGroupsOfSubscription(
    response: AxiosResponse
  ): Promise<AzureResourceGroup[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<AzureResourceGroup[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AzureResourceGroup[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createB2CTenant(
    tenantId: string,
    body: B2CTenantCreationRequestAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<string> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/azure-resources/create/b2c-tenant';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateB2CTenant(_response);
      });
  }

  protected processCreateB2CTenant(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param location (optional)
   * @param body (optional)
   * @return Success
   */
  checkB2CTenantCreationStatus(
    location: string | undefined,
    tenantId: string,
    body: AzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<string> {
    let url_ =
      this.baseUrl +
      '/tenants/{tenantId}/azure-resources/create/b2c-tenant/check-status?';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (location === null)
      throw new Error("The parameter 'location' cannot be null.");
    else if (location !== undefined)
      url_ += 'location=' + encodeURIComponent('' + location) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCheckB2CTenantCreationStatus(_response);
      });
  }

  protected processCheckB2CTenantCreationStatus(
    response: AxiosResponse
  ): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getB2CTenants(
    tenantId: string,
    body: AzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<TenantResource[]> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/azure-resources/list/b2c-tenants';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetB2CTenants(_response);
      });
  }

  protected processGetB2CTenants(
    response: AxiosResponse
  ): Promise<TenantResource[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<TenantResource[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<TenantResource[]>(null as any);
  }
}

export class B2CSupportClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getUserGroupsAndRoles(
    body: GroupsAndRolesRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/b2csupport/groups';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserGroupsAndRoles(_response);
      });
  }

  protected processGetUserGroupsAndRoles(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  validateDomain(
    domain: string,
    countryCode: string,
    body: StringAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ValidationResponse> {
    let url_ = this.baseUrl + '/b2csupport/check-domain/{domain}/{countryCode}';
    if (domain === undefined || domain === null)
      throw new Error("The parameter 'domain' must be defined.");
    url_ = url_.replace('{domain}', encodeURIComponent('' + domain));
    if (countryCode === undefined || countryCode === null)
      throw new Error("The parameter 'countryCode' must be defined.");
    url_ = url_.replace('{countryCode}', encodeURIComponent('' + countryCode));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processValidateDomain(_response);
      });
  }

  protected processValidateDomain(
    response: AxiosResponse
  ): Promise<ValidationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ValidationResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ValidationResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  verifyB2CApp(
    body: B2CAppVerificationRequestAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/b2csupport/verify-b2c-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processVerifyB2CApp(_response);
      });
  }

  protected processVerifyB2CApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }
}

export class BackgroundJobsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  refreshCspTokens(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + '/background-jobs/refresh-csp-tokens';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'PATCH',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRefreshCspTokens(_response);
      });
  }

  protected processRefreshCspTokens(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class BusinessPartnersClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAll(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartnerDataResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/business-partners';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'GET',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<BusinessPartnerDataResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartnerDataResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartnerDataResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    tenantId: string,
    body: BusinessPartner | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/business-partners';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    tenantId: string,
    body: BusinessPartner | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/business-partners';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getById(
    tenantId: string,
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartner[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/business-partners/{id}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(
    response: AxiosResponse
  ): Promise<BusinessPartner[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartner[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartner[]>(null as any);
  }

  /**
   * @return Success
   */
  delete(
    tenantId: string,
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/business-partners/{id}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  bulkCopy(
    tenantId: string,
    body: BusinessPartner[] | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/business-partners/bulk';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBulkCopy(_response);
      });
  }

  protected processBulkCopy(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class CacheClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetCache(
    tenantId: string,
    body: CacheScope[] | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/cache';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'DELETE',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processResetCache(_response);
      });
  }

  protected processResetCache(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class ClustersClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  listClusters(
    cancelToken?: CancelToken | undefined
  ): Promise<ClusterResponse[]> {
    let url_ = this.baseUrl + '/tenant-onboarding/clusters';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processListClusters(_response);
      });
  }

  protected processListClusters(
    response: AxiosResponse
  ): Promise<ClusterResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ClusterResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ClusterResponse[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createCluster(
    body: ClusterCreationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ClusterResponse> {
    let url_ = this.baseUrl + '/tenant-onboarding/clusters';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateCluster(_response);
      });
  }

  protected processCreateCluster(
    response: AxiosResponse
  ): Promise<ClusterResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ClusterResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ClusterResponse>(null as any);
  }

  /**
   * @return Success
   */
  deleteCluster(
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenant-onboarding/clusters/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteCluster(_response);
      });
  }

  protected processDeleteCluster(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class ConfigurationPlansClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  listConfigurationPlans(
    cancelToken?: CancelToken | undefined
  ): Promise<ConfigurationPlanResponse[]> {
    let url_ = this.baseUrl + '/tenant-onboarding/configuration-plans';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processListConfigurationPlans(_response);
      });
  }

  protected processListConfigurationPlans(
    response: AxiosResponse
  ): Promise<ConfigurationPlanResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ConfigurationPlanResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ConfigurationPlanResponse[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createConfigurationPlan(
    body: ConfigurationPlanCreationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ConfigurationPlanResponse> {
    let url_ = this.baseUrl + '/tenant-onboarding/configuration-plans';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateConfigurationPlan(_response);
      });
  }

  protected processCreateConfigurationPlan(
    response: AxiosResponse
  ): Promise<ConfigurationPlanResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ConfigurationPlanResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ConfigurationPlanResponse>(null as any);
  }

  /**
   * @return Success
   */
  deleteConfigurationPlan(
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenant-onboarding/configuration-plans/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteConfigurationPlan(_response);
      });
  }

  protected processDeleteConfigurationPlan(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class CountriesClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getAll(cancelToken?: CancelToken | undefined): Promise<Country[]> {
    let url_ = this.baseUrl + '/global/countries';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(response: AxiosResponse): Promise<Country[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Country[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Country[]>(null as any);
  }
}

export class CustomAttributesClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getByEntityIdAll(
    tenantId: string,
    entityTypeId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<CustomProperty[]> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/custom-attributes/{entityTypeId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (entityTypeId === undefined || entityTypeId === null)
      throw new Error("The parameter 'entityTypeId' must be defined.");
    url_ = url_.replace(
      '{entityTypeId}',
      encodeURIComponent('' + entityTypeId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetByEntityIdAll(_response);
      });
  }

  protected processGetByEntityIdAll(
    response: AxiosResponse
  ): Promise<CustomProperty[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<CustomProperty[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<CustomProperty[]>(null as any);
  }

  /**
   * @return Success
   */
  getByEntityId(
    tenantId: string,
    entityTypeId: string,
    attributeId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<CustomProperty> {
    let url_ =
      this.baseUrl +
      '/tenants/{tenantId}/custom-attributes/{entityTypeId}/{attributeId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (entityTypeId === undefined || entityTypeId === null)
      throw new Error("The parameter 'entityTypeId' must be defined.");
    url_ = url_.replace(
      '{entityTypeId}',
      encodeURIComponent('' + entityTypeId)
    );
    if (attributeId === undefined || attributeId === null)
      throw new Error("The parameter 'attributeId' must be defined.");
    url_ = url_.replace('{attributeId}', encodeURIComponent('' + attributeId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetByEntityId(_response);
      });
  }

  protected processGetByEntityId(
    response: AxiosResponse
  ): Promise<CustomProperty> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<CustomProperty>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<CustomProperty>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createCustomProperty(
    tenantId: string,
    body: CustomProperty | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/custom-attributes';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateCustomProperty(_response);
      });
  }

  protected processCreateCustomProperty(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  delete(
    tenantId: string,
    customPropertyId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/custom-attributes/{customPropertyId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (customPropertyId === undefined || customPropertyId === null)
      throw new Error("The parameter 'customPropertyId' must be defined.");
    url_ = url_.replace(
      '{customPropertyId}',
      encodeURIComponent('' + customPropertyId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class DbMigrationClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  applyMigrations(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/db-migration/migrations/apply';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'PATCH',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processApplyMigrations(_response);
      });
  }

  protected processApplyMigrations(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class EntityTypesClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getEntityTypes(cancelToken?: CancelToken | undefined): Promise<EntityType[]> {
    let url_ = this.baseUrl + '/global/entity-types';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEntityTypes(_response);
      });
  }

  protected processGetEntityTypes(
    response: AxiosResponse
  ): Promise<EntityType[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<EntityType[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<EntityType[]>(null as any);
  }

  /**
   * @return Success
   */
  getById(
    entityTypeId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<EntityType> {
    let url_ = this.baseUrl + '/global/entity-types/{entityTypeId}';
    if (entityTypeId === undefined || entityTypeId === null)
      throw new Error("The parameter 'entityTypeId' must be defined.");
    url_ = url_.replace(
      '{entityTypeId}',
      encodeURIComponent('' + entityTypeId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: AxiosResponse): Promise<EntityType> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<EntityType>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<EntityType>(null as any);
  }
}

export class FilesClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getFileList(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<FileUploadInfo[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/files';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFileList(_response);
      });
  }

  protected processGetFileList(
    response: AxiosResponse
  ): Promise<FileUploadInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<FileUploadInfo[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FileUploadInfo[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getWithDataRequestTest(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<FileUploadInfoDataResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/files/test';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'GET',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetWithDataRequestTest(_response);
      });
  }

  protected processGetWithDataRequestTest(
    response: AxiosResponse
  ): Promise<FileUploadInfoDataResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<FileUploadInfoDataResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FileUploadInfoDataResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    tenantId: string,
    body: FileUploadInfo | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/files/test';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    tenantId: string,
    body: FileUploadInfo | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/files/test';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  bulkCopy(
    tenantId: string,
    body: FileUploadInfo[] | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/files/test/bulk';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBulkCopy(_response);
      });
  }

  protected processBulkCopy(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getFileInformation(
    fileId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<IFileStructure> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/files/{fileId}/info';
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.");
    url_ = url_.replace('{fileId}', encodeURIComponent('' + fileId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFileInformation(_response);
      });
  }

  protected processGetFileInformation(
    response: AxiosResponse
  ): Promise<IFileStructure> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<IFileStructure>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<IFileStructure>(null as any);
  }
}

export class ImportsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  readAll(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Import[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processReadAll(_response);
      });
  }

  protected processReadAll(response: AxiosResponse): Promise<Import[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Import[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Import[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createImport(
    tenantId: string,
    body: Import | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportItem> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateImport(_response);
      });
  }

  protected processCreateImport(response: AxiosResponse): Promise<ImportItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportItem>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportItem>(null as any);
  }

  /**
   * @return Success
   */
  getImportById(
    importId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Import> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/{importId}';
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetImportById(_response);
      });
  }

  protected processGetImportById(response: AxiosResponse): Promise<Import> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Import>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Import>(null as any);
  }

  /**
   * @return Success
   */
  deleteImport(
    importId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/{importId}';
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteImport(_response);
      });
  }

  protected processDeleteImport(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateImport(
    importId: string,
    tenantId: string,
    body: Import | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportItem[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/{importId}';
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateImport(_response);
      });
  }

  protected processUpdateImport(
    response: AxiosResponse
  ): Promise<ImportItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportItem[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportItem[]>(null as any);
  }

  /**
   * @return Success
   */
  getAllTemplates(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportTemplate[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/templates';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllTemplates(_response);
      });
  }

  protected processGetAllTemplates(
    response: AxiosResponse
  ): Promise<ImportTemplate[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportTemplate[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportTemplate[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createImportTemplate(
    tenantId: string,
    body: ImportTemplate | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/templates';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateImportTemplate(_response);
      });
  }

  protected processCreateImportTemplate(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getTemplateById(
    templateId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportTemplate> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/imports/templates/{templateId}';
    if (templateId === undefined || templateId === null)
      throw new Error("The parameter 'templateId' must be defined.");
    url_ = url_.replace('{templateId}', encodeURIComponent('' + templateId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTemplateById(_response);
      });
  }

  protected processGetTemplateById(
    response: AxiosResponse
  ): Promise<ImportTemplate> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportTemplate>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportTemplate>(null as any);
  }

  /**
   * @return Success
   */
  deleteTemplate(
    templateId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/imports/templates/{templateId}';
    if (templateId === undefined || templateId === null)
      throw new Error("The parameter 'templateId' must be defined.");
    url_ = url_.replace('{templateId}', encodeURIComponent('' + templateId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteTemplate(_response);
      });
  }

  protected processDeleteTemplate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateTemplate(
    templateId: string,
    tenantId: string,
    body: ImportTemplate | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/imports/templates/{templateId}';
    if (templateId === undefined || templateId === null)
      throw new Error("The parameter 'templateId' must be defined.");
    url_ = url_.replace('{templateId}', encodeURIComponent('' + templateId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateTemplate(_response);
      });
  }

  protected processUpdateTemplate(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  readAllImportItems(
    tenantId: string,
    importId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportItem[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/{importId}/items';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processReadAllImportItems(_response);
      });
  }

  protected processReadAllImportItems(
    response: AxiosResponse
  ): Promise<ImportItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportItem[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportItem[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createImportItem(
    tenantId: string,
    importId: string,
    body: ImportItem | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportItem> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/{importId}/items';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateImportItem(_response);
      });
  }

  protected processCreateImportItem(
    response: AxiosResponse
  ): Promise<ImportItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportItem>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportItem>(null as any);
  }

  /**
   * @return Success
   */
  getImportItemById(
    tenantId: string,
    importId: string,
    itemId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportItem> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/imports/{importId}/items/{itemId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    if (itemId === undefined || itemId === null)
      throw new Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetImportItemById(_response);
      });
  }

  protected processGetImportItemById(
    response: AxiosResponse
  ): Promise<ImportItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportItem>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportItem>(null as any);
  }

  /**
   * @return Success
   */
  deleteImportItem(
    tenantId: string,
    importId: string,
    itemId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/imports/{importId}/items/{itemId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    if (itemId === undefined || itemId === null)
      throw new Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteImportItem(_response);
      });
  }

  protected processDeleteImportItem(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateImportItem(
    tenantId: string,
    importId: string,
    itemId: string,
    body: ImportItem | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ImportItem> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/imports/{importId}/items/{itemId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (importId === undefined || importId === null)
      throw new Error("The parameter 'importId' must be defined.");
    url_ = url_.replace('{importId}', encodeURIComponent('' + importId));
    if (itemId === undefined || itemId === null)
      throw new Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateImportItem(_response);
      });
  }

  protected processUpdateImportItem(
    response: AxiosResponse
  ): Promise<ImportItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ImportItem>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ImportItem>(null as any);
  }

  /**
   * @return Success
   */
  autoImport(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/re-import';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAutoImport(_response);
      });
  }

  protected processAutoImport(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<number>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  startImport(
    tenantId: string,
    body: StartImportRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/start';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processStartImport(_response);
      });
  }

  protected processStartImport(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<number>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  autoMapping(
    tenantId: string,
    body: AutoMappingRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/imports/auto-mapping';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAutoMapping(_response);
      });
  }

  protected processAutoMapping(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<number>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<number>(null as any);
  }
}

export class KubernetesClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getIngressControllers(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<string[]> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/kubernetes/ingress-controllers/list';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetIngressControllers(_response);
      });
  }

  protected processGetIngressControllers(
    response: AxiosResponse
  ): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<string[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @param name (optional)
   * @param hostname (optional)
   * @return Success
   */
  addIngressControllers(
    name: string | undefined,
    hostname: string | undefined,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<V1IngressStatus[]> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/kubernetes/ingress-controllers/add?';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (name === null) throw new Error("The parameter 'name' cannot be null.");
    else if (name !== undefined)
      url_ += 'name=' + encodeURIComponent('' + name) + '&';
    if (hostname === null)
      throw new Error("The parameter 'hostname' cannot be null.");
    else if (hostname !== undefined)
      url_ += 'hostname=' + encodeURIComponent('' + hostname) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddIngressControllers(_response);
      });
  }

  protected processAddIngressControllers(
    response: AxiosResponse
  ): Promise<V1IngressStatus[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<V1IngressStatus[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<V1IngressStatus[]>(null as any);
  }

  /**
   * @return Success
   */
  resetIngressControllersConfig(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ =
      this.baseUrl + '/tenants/{tenantId}/kubernetes/ingress-controllers/reset';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processResetIngressControllersConfig(_response);
      });
  }

  protected processResetIngressControllersConfig(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param name (optional)
   * @return Success
   */
  removeIngressControllers(
    name: string | undefined,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<V1Status> {
    let url_ =
      this.baseUrl +
      '/tenants/{tenantId}/kubernetes/ingress-controllers/remove?';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (name === null) throw new Error("The parameter 'name' cannot be null.");
    else if (name !== undefined)
      url_ += 'name=' + encodeURIComponent('' + name) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRemoveIngressControllers(_response);
      });
  }

  protected processRemoveIngressControllers(
    response: AxiosResponse
  ): Promise<V1Status> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<V1Status>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<V1Status>(null as any);
  }
}

export class MediaClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAll(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<MediaDataResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/media';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'GET',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(response: AxiosResponse): Promise<MediaDataResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<MediaDataResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<MediaDataResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    tenantId: string,
    body: Media | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<Media> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/media';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<Media> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Media>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Media>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(
    mediaId: string,
    tenantId: string,
    body: Media | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<Media> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/media/{mediaId}';
    if (mediaId === undefined || mediaId === null)
      throw new Error("The parameter 'mediaId' must be defined.");
    url_ = url_.replace('{mediaId}', encodeURIComponent('' + mediaId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PUT',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<Media> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Media>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Media>(null as any);
  }

  /**
   * @return Success
   */
  getById(
    mediaId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Media> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/media/{mediaId}';
    if (mediaId === undefined || mediaId === null)
      throw new Error("The parameter 'mediaId' must be defined.");
    url_ = url_.replace('{mediaId}', encodeURIComponent('' + mediaId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: AxiosResponse): Promise<Media> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Media>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Media>(null as any);
  }

  /**
   * @return Success
   */
  deleteMedia(
    mediaId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/media/{mediaId}';
    if (mediaId === undefined || mediaId === null)
      throw new Error("The parameter 'mediaId' must be defined.");
    url_ = url_.replace('{mediaId}', encodeURIComponent('' + mediaId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteMedia(_response);
      });
  }

  protected processDeleteMedia(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  resize(
    fileId: string,
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/media/{fileId}/resize';
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.");
    url_ = url_.replace('{fileId}', encodeURIComponent('' + fileId));
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processResize(_response);
      });
  }

  protected processResize(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class PriceListsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAll(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<PriceListDataResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/price-lists/read';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<PriceListDataResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<PriceListDataResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PriceListDataResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(
    tenantId: string,
    body: PriceList | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<PriceList> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/price-lists';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<PriceList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<PriceList>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PriceList>(null as any);
  }
}

export class ProductsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getProducts(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ProductProductResponse> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProducts(_response);
      });
  }

  protected processGetProducts(
    response: AxiosResponse
  ): Promise<ProductProductResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ProductProductResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductProductResponse>(null as any);
  }

  /**
   * @return Success
   */
  getProductById(
    tenantId: string,
    productId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<Product> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/{productId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProductById(_response);
      });
  }

  protected processGetProductById(response: AxiosResponse): Promise<Product> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<Product>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<Product>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   * @deprecated
   */
  getAll(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ProductProductResponse> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/get-all';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<ProductProductResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ProductProductResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductProductResponse>(null as any);
  }

  /**
   * @return Success
   */
  getFilterList(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<CustomAttribute[]> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/filter-list';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFilterList(_response);
      });
  }

  protected processGetFilterList(
    response: AxiosResponse
  ): Promise<CustomAttribute[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<CustomAttribute[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<CustomAttribute[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getProductsFromRepoTest(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ProductDataResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/test';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProductsFromRepoTest(_response);
      });
  }

  protected processGetProductsFromRepoTest(
    response: AxiosResponse
  ): Promise<ProductDataResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ProductDataResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductDataResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getDistinctValues(
    tenantId: string,
    body: DistinctValuesRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<DistinctValueResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/distinct-values';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDistinctValues(_response);
      });
  }

  protected processGetDistinctValues(
    response: AxiosResponse
  ): Promise<DistinctValueResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<DistinctValueResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DistinctValueResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  delete(
    tenantId: string,
    body: FilterItem[] | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/test-delete';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelete(_response);
      });
  }

  protected processDelete(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<number>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * @return Success
   */
  truncateData(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<number> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/products/test-truncate';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processTruncateData(_response);
      });
  }

  protected processTruncateData(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<number>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<number>(null as any);
  }
}

export class ProductVariantsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getProductVariants(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ProductVariantProductResponse> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/product-variants';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetProductVariants(_response);
      });
  }

  protected processGetProductVariants(
    response: AxiosResponse
  ): Promise<ProductVariantProductResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ProductVariantProductResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductVariantProductResponse>(null as any);
  }

  /**
   * @return Success
   */
  getById(
    tenantId: string,
    itemId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<ProductVariant> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/product-variants/{itemId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (itemId === undefined || itemId === null)
      throw new Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: AxiosResponse): Promise<ProductVariant> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ProductVariant>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ProductVariant>(null as any);
  }
}

export class SupplierPriceListItemsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getAll(
    tenantId: string,
    body: DataRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SupplierPriceListItemDataResult> {
    let url_ = this.baseUrl + '/tenants/{tenantId}/supplier-price-list-items';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAll(_response);
      });
  }

  protected processGetAll(
    response: AxiosResponse
  ): Promise<SupplierPriceListItemDataResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<SupplierPriceListItemDataResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SupplierPriceListItemDataResult>(null as any);
  }

  /**
   * @return Success
   */
  getPriceListItemProductById(
    tenantId: string,
    priceListItemId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<SupplierPriceListItem> {
    let url_ =
      this.baseUrl +
      '/tenants/{tenantId}/supplier-price-list-items/{priceListItemId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (priceListItemId === undefined || priceListItemId === null)
      throw new Error("The parameter 'priceListItemId' must be defined.");
    url_ = url_.replace(
      '{priceListItemId}',
      encodeURIComponent('' + priceListItemId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPriceListItemProductById(_response);
      });
  }

  protected processGetPriceListItemProductById(
    response: AxiosResponse
  ): Promise<SupplierPriceListItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<SupplierPriceListItem>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SupplierPriceListItem>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getDistinctValues(
    tenantId: string,
    body: DistinctValuesRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<DistinctValueResult> {
    let url_ =
      this.baseUrl +
      '/tenants/{tenantId}/supplier-price-list-items/distinct-values';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDistinctValues(_response);
      });
  }

  protected processGetDistinctValues(
    response: AxiosResponse
  ): Promise<DistinctValueResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<DistinctValueResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<DistinctValueResult>(null as any);
  }

  /**
   * @return Success
   */
  getFilterList(
    tenantId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<EntityTypeProperty[]> {
    let url_ =
      this.baseUrl +
      '/tenants/{tenantId}/supplier-price-list-items/filter-list';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetFilterList(_response);
      });
  }

  protected processGetFilterList(
    response: AxiosResponse
  ): Promise<EntityTypeProperty[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<EntityTypeProperty[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<EntityTypeProperty[]>(null as any);
  }
}

export class T1TenantsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  listTenants(
    businessPartnerId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<TenantResponse[]> {
    let url_ =
      this.baseUrl +
      '/tenant-onboarding/t1-tenants/list-tenants-of-business-partner/{businessPartnerId}';
    if (businessPartnerId === undefined || businessPartnerId === null)
      throw new Error("The parameter 'businessPartnerId' must be defined.");
    url_ = url_.replace(
      '{businessPartnerId}',
      encodeURIComponent('' + businessPartnerId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processListTenants(_response);
      });
  }

  protected processListTenants(
    response: AxiosResponse
  ): Promise<TenantResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<TenantResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<TenantResponse[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createTenant(
    body: TenantCreationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<TenantResponse> {
    let url_ = this.baseUrl + '/tenant-onboarding/t1-tenants';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateTenant(_response);
      });
  }

  protected processCreateTenant(
    response: AxiosResponse
  ): Promise<TenantResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<TenantResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<TenantResponse>(null as any);
  }
}

export class TenantBusinessPartnersClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getTenantBusinessPartnerOfUser(
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartnerResponse> {
    let url_ = this.baseUrl + '/tenant-onboarding/business-partners';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTenantBusinessPartnerOfUser(_response);
      });
  }

  protected processGetTenantBusinessPartnerOfUser(
    response: AxiosResponse
  ): Promise<BusinessPartnerResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartnerResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartnerResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerTenantBusinessPartner(
    body: TenantBusinessPartnerCreationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartnerResponse> {
    let url_ = this.baseUrl + '/tenant-onboarding/business-partners/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterTenantBusinessPartner(_response);
      });
  }

  protected processRegisterTenantBusinessPartner(
    response: AxiosResponse
  ): Promise<BusinessPartnerResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartnerResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartnerResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  verifyDomain(
    body: BusinessPartnerDomainVerificationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartnerDomainVerificationResponse> {
    let url_ =
      this.baseUrl + '/tenant-onboarding/business-partners/verify-domain';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processVerifyDomain(_response);
      });
  }

  protected processVerifyDomain(
    response: AxiosResponse
  ): Promise<BusinessPartnerDomainVerificationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartnerDomainVerificationResponse>(
        result200
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartnerDomainVerificationResponse>(
      null as any
    );
  }

  /**
   * @return Success
   */
  deleteTenantBusinessPartner(
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + '/tenant-onboarding/business-partners/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'DELETE',
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteTenantBusinessPartner(_response);
      });
  }

  protected processDeleteTenantBusinessPartner(
    response: AxiosResponse
  ): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export class TenantConfigsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getById(
    tenantName: string,
    cancelToken?: CancelToken | undefined
  ): Promise<FrontendConfig> {
    let url_ = this.baseUrl + '/tenant-configs/{tenantName}';
    if (tenantName === undefined || tenantName === null)
      throw new Error("The parameter 'tenantName' must be defined.");
    url_ = url_.replace('{tenantName}', encodeURIComponent('' + tenantName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetById(_response);
      });
  }

  protected processGetById(response: AxiosResponse): Promise<FrontendConfig> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<FrontendConfig>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FrontendConfig>(null as any);
  }

  /**
   * @return Success
   */
  getTenantClientIds(
    cancelToken?: CancelToken | undefined
  ): Promise<ClientApplicationIdResponse> {
    let url_ =
      this.baseUrl + '/tenant-configs/microsoft/identity-association-config';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTenantClientIds(_response);
      });
  }

  protected processGetTenantClientIds(
    response: AxiosResponse
  ): Promise<ClientApplicationIdResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<ClientApplicationIdResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ClientApplicationIdResponse>(null as any);
  }

  /**
   * @return Success
   */
  readSecret(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/tenant-configs/testSlava';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processReadSecret(_response);
      });
  }

  protected processReadSecret(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @return Success
   */
  writeSecret(cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = this.baseUrl + '/tenant-configs/writeSecret';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processWriteSecret(_response);
      });
  }

  protected processWriteSecret(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @return Success
   */
  getPrivateTenantConfig(
    tenantName: string,
    cancelToken?: CancelToken | undefined
  ): Promise<TenantConfig> {
    let url_ = this.baseUrl + '/tenant-configs/private/{tenantName}';
    if (tenantName === undefined || tenantName === null)
      throw new Error("The parameter 'tenantName' must be defined.");
    url_ = url_.replace('{tenantName}', encodeURIComponent('' + tenantName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPrivateTenantConfig(_response);
      });
  }

  protected processGetPrivateTenantConfig(
    response: AxiosResponse
  ): Promise<TenantConfig> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<TenantConfig>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<TenantConfig>(null as any);
  }
}

export class TenantCspIntegrationsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerPartnerTenant(
    body: TenantCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ =
      this.baseUrl + '/tenant-csp-integrations/register-csp-partner-tenant';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterPartnerTenant(_response);
      });
  }

  protected processRegisterPartnerTenant(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerPartnerNativeApp(
    body: CspNativeAppRegistrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ =
      this.baseUrl + '/tenant-csp-integrations/register-csp-partner-native-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterPartnerNativeApp(_response);
      });
  }

  protected processRegisterPartnerNativeApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setupCspWebApp(
    body: CspWebAppRegistrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ =
      this.baseUrl + '/tenant-csp-integrations/setup-csp-partner-web-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSetupCspWebApp(_response);
      });
  }

  protected processSetupCspWebApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerGdapSecurityGroup(
    body: BaseAuthorizedCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ =
      this.baseUrl + '/tenant-csp-integrations/create-gdap-security-group';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterGdapSecurityGroup(_response);
      });
  }

  protected processRegisterGdapSecurityGroup(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerGdapApp(
    body: BaseAuthorizedCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-csp-integrations/create-gdap-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterGdapApp(_response);
      });
  }

  protected processRegisterGdapApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  assignAppToGroup(
    body: BaseAuthorizedCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ =
      this.baseUrl +
      '/tenant-csp-integrations/assign-gdap-app-to-security-group';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAssignAppToGroup(_response);
      });
  }

  protected processAssignAppToGroup(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getIntegrationCredentials(
    body: BaseCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<MsIntegrationCredentialsResponse> {
    let url_ =
      this.baseUrl + '/tenant-csp-integrations/get-csp-integration-credentials';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetIntegrationCredentials(_response);
      });
  }

  protected processGetIntegrationCredentials(
    response: AxiosResponse
  ): Promise<MsIntegrationCredentialsResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<MsIntegrationCredentialsResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<MsIntegrationCredentialsResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  generateCspRefreshToken(
    body: CspAuthCodeRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ =
      this.baseUrl + '/tenant-csp-integrations/generate-csp-refresh-token';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGenerateCspRefreshToken(_response);
      });
  }

  protected processGenerateCspRefreshToken(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  testCspConnection(
    body: BaseCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-csp-integrations/test-csp-connection';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processTestCspConnection(_response);
      });
  }

  protected processTestCspConnection(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @return Success
   */
  getCspIntegrationDetails(
    integrationId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<CspIntegrationDetailedInformation> {
    let url_ = this.baseUrl + '/tenant-csp-integrations/{integrationId}';
    if (integrationId === undefined || integrationId === null)
      throw new Error("The parameter 'integrationId' must be defined.");
    url_ = url_.replace(
      '{integrationId}',
      encodeURIComponent('' + integrationId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetCspIntegrationDetails(_response);
      });
  }

  protected processGetCspIntegrationDetails(
    response: AxiosResponse
  ): Promise<CspIntegrationDetailedInformation> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<CspIntegrationDetailedInformation>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<CspIntegrationDetailedInformation>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updatCspIntegrationDetails(
    integrationId: string,
    body: CspIntegrationUpdateRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-csp-integrations/{integrationId}';
    if (integrationId === undefined || integrationId === null)
      throw new Error("The parameter 'integrationId' must be defined.");
    url_ = url_.replace(
      '{integrationId}',
      encodeURIComponent('' + integrationId)
    );
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'PATCH',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdatCspIntegrationDetails(_response);
      });
  }

  protected processUpdatCspIntegrationDetails(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  deleteCspIntegrationDetails(
    integrationId: string,
    body: CspIntegrationDeletionRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-csp-integrations/{integrationId}';
    if (integrationId === undefined || integrationId === null)
      throw new Error("The parameter 'integrationId' must be defined.");
    url_ = url_.replace(
      '{integrationId}',
      encodeURIComponent('' + integrationId)
    );
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'DELETE',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteCspIntegrationDetails(_response);
      });
  }

  protected processDeleteCspIntegrationDetails(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getEntraResourcesForDeletion(
    body: BaseAuthorizedCspIntegrationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<AzureResourceInfo[]> {
    let url_ =
      this.baseUrl +
      '/tenant-csp-integrations/get-entra-resources-for-deletion';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetEntraResourcesForDeletion(_response);
      });
  }

  protected processGetEntraResourcesForDeletion(
    response: AxiosResponse
  ): Promise<AzureResourceInfo[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<AzureResourceInfo[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<AzureResourceInfo[]>(null as any);
  }
}

export class TenantIntegrationsClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  getTenantIntegrations(
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartnerIntegrationResponse[]> {
    let url_ = this.baseUrl + '/tenant-integrations/get-tenant-integrations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTenantIntegrations(_response);
      });
  }

  protected processGetTenantIntegrations(
    response: AxiosResponse
  ): Promise<BusinessPartnerIntegrationResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartnerIntegrationResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartnerIntegrationResponse[]>(null as any);
  }

  /**
   * @return Success
   */
  getTenantIntegration(
    integrationId: string,
    cancelToken?: CancelToken | undefined
  ): Promise<BusinessPartnerIntegrationDetailsResponse> {
    let url_ =
      this.baseUrl +
      '/tenant-integrations/get-tenant-integration/{integrationId}';
    if (integrationId === undefined || integrationId === null)
      throw new Error("The parameter 'integrationId' must be defined.");
    url_ = url_.replace(
      '{integrationId}',
      encodeURIComponent('' + integrationId)
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'GET',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTenantIntegration(_response);
      });
  }

  protected processGetTenantIntegration(
    response: AxiosResponse
  ): Promise<BusinessPartnerIntegrationDetailsResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<BusinessPartnerIntegrationDetailsResponse>(
        result200
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<BusinessPartnerIntegrationDetailsResponse>(
      null as any
    );
  }
}

export class TenantOnboardingClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();

    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerIdentityExperienceFrameworkApp(
    body: GuidAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/create-ief-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterIdentityExperienceFrameworkApp(_response);
      });
  }

  protected processRegisterIdentityExperienceFrameworkApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerProxyIdentityExperienceFrameworkApp(
    body: GuidAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/create-proxy-ief-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterProxyIdentityExperienceFrameworkApp(
          _response
        );
      });
  }

  protected processRegisterProxyIdentityExperienceFrameworkApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerTotalOneIdentityApp(
    body: GuidAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/create-identity-app';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterTotalOneIdentityApp(_response);
      });
  }

  protected processRegisterTotalOneIdentityApp(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  registerPolicyKeys(
    body: GuidAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/register-ief-keys';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterPolicyKeys(_response);
      });
  }

  protected processRegisterPolicyKeys(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  uploadPolicies(
    body: GuidAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/upload-ief-policies';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUploadPolicies(_response);
      });
  }

  protected processUploadPolicies(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createRoleGroups(
    body: GuidAzureAuthorizedRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/create-role-groups';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: 'POST',
      url: url_,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateRoleGroups(_response);
      });
  }

  protected processCreateRoleGroups(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @param businessPartnerId (optional)
   * @return Success
   */
  createTenantDbUser(
    businessPartnerId: string | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/create-db-user?';
    if (businessPartnerId === null)
      throw new Error("The parameter 'businessPartnerId' cannot be null.");
    else if (businessPartnerId !== undefined)
      url_ +=
        'businessPartnerId=' + encodeURIComponent('' + businessPartnerId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateTenantDbUser(_response);
      });
  }

  protected processCreateTenantDbUser(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @return Success
   */
  registerIngressControllers(
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/register-ingress-controllers';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRegisterIngressControllers(_response);
      });
  }

  protected processRegisterIngressControllers(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }

  /**
   * @return Success
   */
  migrateDbSchema(
    cancelToken?: CancelToken | undefined
  ): Promise<OnboardingActionResult> {
    let url_ = this.baseUrl + '/tenant-onboarding/migrate-db-schema';
    url_ = url_.replace(/[?&]$/, '');

    let options_: AxiosRequestConfig = {
      method: 'POST',
      url: url_,
      headers: {
        Accept: 'text/plain',
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processMigrateDbSchema(_response);
      });
  }

  protected processMigrateDbSchema(
    response: AxiosResponse
  ): Promise<OnboardingActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === 'object') {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = JSON.parse(resultData200);
      return Promise.resolve<OnboardingActionResult>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<OnboardingActionResult>(null as any);
  }
}

export interface Authentication {
  tenantId?: string;
  clientId?: string;
  domain?: string | undefined;
  tenantName?: string | undefined;
  policy?: string | undefined;
  loginScope?: string | undefined;
  authority?: string | undefined;
}

export interface AutoMappingRequest {
  importTemplateId?: string;
}

export interface AzureAuthorizedRequest {
  authToken?: string | undefined;
}

export interface AzureResourceGroup {
  id?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  location?: string | undefined;
}

export interface AzureResourceInfo {
  resourceId?: string | undefined;
  resourceName?: string | undefined;
}

export interface AzureSubscription {
  id?: string | undefined;
  authorizationSource?: string | undefined;
  subscriptionId?: string | undefined;
  tenantId?: string | undefined;
  displayName?: string | undefined;
  state?: string | undefined;
}

export interface B2CAppVerificationRequest {
  b2CTenantId?: string | undefined;
  mpnId?: string | undefined;
}

export interface B2CAppVerificationRequestAzureAuthorizedRequest {
  authToken?: string | undefined;
  value?: B2CAppVerificationRequest;
}

export interface B2CTenantCreationRequest {
  subscriptionId?: string | undefined;
  groupName?: string | undefined;
  region?: string | undefined;
  country?: string | undefined;
  orgName?: string | undefined;
  orgDomain?: string | undefined;
}

export interface B2CTenantCreationRequestAzureAuthorizedRequest {
  authToken?: string | undefined;
  value?: B2CTenantCreationRequest;
}

export interface BaseAuthorizedCspIntegrationRequest {
  integrationId?: string;
  authToken?: string | undefined;
}

export interface BaseCspIntegrationRequest {
  integrationId?: string;
}

export enum BillingFrequency {
  None = 'None',
  Monthly = 'Monthly',
  Annually = 'Annually',
  Triennial = 'Triennial',
}

export interface BusinessPartner {
  id?: string;
  customProperties?: { [key: string]: any } | undefined;
  name?: string | undefined;
  externalId?: string | undefined;
  segment?: BusinessPartnerSegment;
  addresses?: BusinessPartnerAddress[] | undefined;
  domains?: BusinessPartnerDomain[] | undefined;
}

export interface BusinessPartnerAddress {
  id?: string;
  businessPartnerId?: string;
  isLegal?: boolean;
  isBilling?: boolean;
  isContact?: boolean;
  isShipping?: boolean;
  siteName?: string | undefined;
  siteCode?: string | undefined;
  countryId?: string;
  line1?: string | undefined;
  line2?: string | undefined;
  line3?: string | undefined;
  postalCode?: string | undefined;
  city?: string | undefined;
  stateOrProvince?: string | undefined;
  postOfficeBox?: string | undefined;
  longitude?: number | undefined;
  latitude?: number | undefined;
  note?: string | undefined;
}

export interface BusinessPartnerDataResult {
  entities?: BusinessPartner[] | undefined;
  resultCount?: number | undefined;
}

export interface BusinessPartnerDomain {
  id?: string;
  name: string;
  businessPartnerId?: string;
}

export interface BusinessPartnerDomainVerificationRequest {
  domain?: string | undefined;
}

export interface BusinessPartnerDomainVerificationResponse {
  isDomainAvailable?: boolean;
  errorMessage?: string | undefined;
}

export interface BusinessPartnerIntegrationDetailsResponse {
  integrationId?: string;
  businessPartnerId?: string;
  integrationType?: BusinessPartnerIntegrationType;
  integrationStatus?: BusinessPartnerIntegrationStatus;
  integrationStatusDisplayName?: string | undefined;
  displayName?: string | undefined;
  integrationDetails?: { [key: string]: string } | undefined;
}

export interface BusinessPartnerIntegrationResponse {
  id?: string;
  businessPartnerId?: string;
  integrationType?: BusinessPartnerIntegrationType;
  integrationStatus?: BusinessPartnerIntegrationStatus;
  integrationStatusDisplayName?: string | undefined;
  displayName?: string | undefined;
}

export enum BusinessPartnerIntegrationStatus {
  Active = 'Active',
  Disabled = 'Disabled',
  NotConfigured = 'NotConfigured',
  ActionRequired = 'ActionRequired',
}

export enum BusinessPartnerIntegrationType {
  MsCsp = 'MsCsp',
  MsGraph = 'MsGraph',
  Google = 'Google',
  Amazon = 'Amazon',
}

export interface BusinessPartnerResponse {
  id?: string;
  name?: string | undefined;
  addressLine1?: string | undefined;
  addressLine2?: string | undefined;
  contactFirstName?: string | undefined;
  contactLastName?: string | undefined;
  contactPhone?: string | undefined;
  contactEmail?: string | undefined;
  domain?: string | undefined;
}

export enum BusinessPartnerSegment {
  Private = 'Private',
  Corporate = 'Corporate',
  Government = 'Government',
  Academic = 'Academic',
  Charity = 'Charity',
}

export enum CacheScope {
  CustomAttributes = 'CustomAttributes',
  Tenants = 'Tenants',
  Global = 'Global',
}

export interface ClientApplicationIdItem {
  applicationId?: string | undefined;
}

export interface ClientApplicationIdResponse {
  associatedApplications?: ClientApplicationIdItem[] | undefined;
}

export interface ClusterCreationRequest {
  name?: string | undefined;
  location?: string | undefined;
  apiUrl?: string | undefined;
}

export interface ClusterResponse {
  id?: string;
  name?: string | undefined;
  location?: string | undefined;
}

export interface ConfigurationPlanCreationRequest {
  displayName?: string | undefined;
  subscriptionId?: string;
  resourceGroupName?: string | undefined;
}

export interface ConfigurationPlanResponse {
  id?: string;
  displayName?: string | undefined;
}

export interface Country {
  id?: string;
  name: string;
  iso3166Part1Alpha2?: string | undefined;
  nativeName?: string | undefined;
  iso8601DateFormat?: string | undefined;
  iso8601FirstDayOfWeek?: number;
  callingCode?: string | undefined;
  postalCodesFormat?: string | undefined;
  postalCodesRegex?: string | undefined;
  flagSvg?: string | undefined;
  flagWebp?: string | undefined;
  flagAltText?: string | undefined;
}

export interface CreateTenantProperties {
  displayName?: string | undefined;
  countryCode?: string | undefined;
  isGoLocalTenant?: boolean;
}

export interface CspAuthCodeRequest extends BaseCspIntegrationRequest {
  authCode?: string | undefined;
}

export interface CspIntegrationDeletionRequest {
  removeEntraIdResources?: boolean;
  authToken?: string | undefined;
}

export interface CspIntegrationDetailedInformation {
  integrationId?: string;
  generalInformation?: CspIntegrationGeneralInformation;
  nativeApp?: CspNativeAppDetails;
  webApp?: CspWebAppDetails;
}

export interface CspIntegrationGeneralInformation {
  integrationDisplayName?: string | undefined;
  partnerName?: string | undefined;
  partnerDomain?: string | undefined;
  tenantId?: string | undefined;
}

export interface CspIntegrationUpdateRequest {
  generalInformation?: CspIntegrationGeneralInformation;
  nativeApp?: CspNativeApp;
  webApp?: CspWebApp;
}

export interface CspNativeApp {
  appId?: string;
  appName?: string | undefined;
}

export interface CspNativeAppDetails {
  appId?: string | undefined;
  appName?: string | undefined;
}

export interface CspNativeAppRegistrationRequest
  extends BaseCspIntegrationRequest {
  nativeApp?: CspNativeApp;
}

export interface CspSecret {
  secretId?: string;
  secretValue?: string | undefined;
  secretExpirationDate?: Date;
}

export interface CspWebApp {
  appId?: string;
  appName?: string | undefined;
  secret?: CspSecret;
}

export interface CspWebAppDetails {
  appId?: string | undefined;
  appName?: string | undefined;
  secret?: CspSecret;
}

export interface CspWebAppRegistrationRequest
  extends BaseAuthorizedCspIntegrationRequest {
  webApp?: CspWebApp;
}

export interface Currency {
  id?: string;
  name: string;
  iso4217Alpha?: string | undefined;
  iso4217Numeric?: string | undefined;
  defaultSymbol?: string | undefined;
  numberOfDecimalPlaces?: number;
  roundToDecimalPlacesForLineItem?: number | undefined;
  roundToDecimalPlacesForSum?: number | undefined;
  defaultNotation?: string | undefined;
  flagSvg?: string | undefined;
  flagWebp?: string | undefined;
  flagAltText?: string | undefined;
}

export interface CustomAttribute {
  id?: string;
  name?: string | undefined;
  displayName?: string | undefined;
}

export interface EntityTypePropertyBase {
  id?: string;
  name: string;
  entityTypeId?: string;
  displayName?: string | undefined;
  propertyType?: PropertyType;
  nullable?: boolean;
  numericIsSigned?: boolean | undefined;
  stringMaxLength?: number | undefined;
  supportsTranslation?: boolean;
}

export interface CustomProperty extends EntityTypePropertyBase {}

export interface DataRequest {
  properties?: string[] | undefined;
  filters?: FilterItem[] | undefined;
  sorting?: SortItem[] | undefined;
  pageSize?: number;
  offset?: number;
  includeResultCount?: boolean;
}

export enum DatabaseType {
  Global = 'Global',
  Tenant = 'Tenant',
}

export interface DistinctValueResult {
  propertyResults?: { [key: string]: { [key: string]: number } } | undefined;
}

export interface DistinctValuesRequest {
  properties?: string[] | undefined;
  filters?: FilterItem[] | undefined;
}

export interface EntityType {
  id?: string;
  name: string;
  displayName?: string | undefined;
  databaseType?: DatabaseType;
  dllName?: string | undefined;
  namespace?: string | undefined;
  hasCustomProperties?: boolean;
  readonly properties?: EntityTypeProperty[] | undefined;
}

export interface EntityTypeProperty extends EntityTypePropertyBase {
  isPrimaryKey?: boolean;
  referenceEntityTypeId?: string | undefined;
  typeDllName?: string | undefined;
  typeNamespace?: string | undefined;
  typeName?: string | undefined;
}

export enum FileAccessLevel {
  Private = 'Private',
  Public = 'Public',
}

export interface FileReadOptions {
  csvSeparator?: string | undefined;
  worksheet?: string | undefined;
  zipPath?: string | undefined;
  staticAttributes?: { [key: string]: string } | undefined;
}

export enum FileStatus {
  Uploading = 'Uploading',
  UploadComplete = 'UploadComplete',
  Processing = 'Processing',
  ToBeDeleted = 'ToBeDeleted',
  Error = 'Error',
}

export interface FileUploadInfo {
  id?: string;
  name: string;
  accessLevel?: FileAccessLevel;
  md5?: string | undefined;
  status?: FileStatus;
  path?: string | undefined;
  sizeInBytes?: number;
  metadata?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
}

export interface FileUploadInfoDataResult {
  entities?: FileUploadInfo[] | undefined;
  resultCount?: number | undefined;
}

export interface FilterItem {
  connector?: FilterConnector;
  negateExpression?: boolean;
  condition?: FilterCondition;
  subFilters?: FilterItem[] | undefined;
}

export interface FilterCondition extends FilterItem {
  property?: string | undefined;
  operator?: FilterOperator;
  value?: any | undefined;
}

export enum FilterConnector {
  And = 'And',
  Or = 'Or',
}

export enum FilterOperator {
  Equal = 'Equal',
  GreaterThan = 'GreaterThan',
  LessThan = 'LessThan',
  GreaterThanOrEqual = 'GreaterThanOrEqual',
  LessThanOrEqual = 'LessThanOrEqual',
  NotEqual = 'NotEqual',
  Between = 'Between',
  Like = 'Like',
  In = 'In',
}

export interface FrontendConfig {
  apiUrl?: string | undefined;
  tenantId?: string;
  currencies?: Currency[] | undefined;
  authentication?: Authentication;
}

export interface GroupsAndRolesRequest {
  email?: string | undefined;
}

export interface GuidAzureAuthorizedRequest {
  authToken?: string | undefined;
  value?: string;
}

export interface IFileStructure {
  typeIdentifier?: string | undefined;
}

export interface Import {
  id?: string;
  name?: string | undefined;
  entityTypeId?: string;
  order?: number;
}

export interface ImportItem {
  id?: string;
  fileUploadInfoId?: string;
  importTemplateId?: string;
  importId?: string;
  order?: number;
  configuration?: FileReadOptions;
  configurationHash?: string | undefined;
}

export interface ImportTemplate {
  id?: string;
  name: string;
  entityTypeId?: string;
  configuration?: ImportTemplateConfiguration;
}

export interface ImportTemplateConfiguration {
  externalId?: string[] | undefined;
  objectMapping?: { [key: string]: string } | undefined;
  attributeMapping?: { [key: string]: string } | undefined;
}

export interface Media {
  id?: string;
  fileUploadInfoId?: string | undefined;
  name?: string | undefined;
  mediaType?: MediaType;
  fullUrl?: string | undefined;
  items?: MediaImageItem[] | undefined;
}

export interface MediaDataResult {
  entities?: Media[] | undefined;
  resultCount?: number | undefined;
}

export interface MediaImageItem {
  id?: string;
  mediaId?: string;
  fileUploadInfoId?: string;
  fullUrl?: string | undefined;
  width?: number;
  height?: number;
}

export enum MediaType {
  Image = 'Image',
  Video = 'Video',
  Pdf = 'Pdf',
  Youtube = 'Youtube',
  Vimeo = 'Vimeo',
}

export interface MsIntegrationCredentialsResponse {
  clientId?: string | undefined;
  tenantId?: string;
}

export interface OnboardingActionResult {
  actionName?: string | undefined;
  id?: string | undefined;
  isActionSuccessful?: boolean;
  details?: string | undefined;
}

export interface OnboardingActionResult_1 extends OnboardingActionResult {
  value?: T;
}

export interface PriceList {
  id?: string;
  name: string;
  businessPartnerId?: string;
}

export interface PriceListDataResult {
  entities?: PriceList[] | undefined;
  resultCount?: number | undefined;
}

export interface PriceListItem {
  id?: string;
  customProperties?: { [key: string]: any } | undefined;
  externalId?: string | undefined;
  priceListId?: string;
  productVariantId?: string;
  currencyId?: string;
  importId?: string | undefined;
  validFrom?: Date;
  validTo?: Date;
  price?: number;
  priceMsrp?: number | undefined;
  state?: PriceListItemState;
  priceForMonths?: number | undefined;
}

export enum PriceListItemState {
  New = 'New',
  Added = 'Added',
  Changed = 'Changed',
  Unchanged = 'Unchanged',
  Deprecated = 'Deprecated',
  Deleted = 'Deleted',
}

export interface Product {
  id?: string;
  customProperties?: { [key: string]: any } | undefined;
  name?: string | undefined;
  externalId?: string | undefined;
  price?: number | undefined;
}

export interface ProductDataResult {
  entities?: Product[] | undefined;
  resultCount?: number | undefined;
}

export interface ProductProductResponse {
  count?: number | undefined;
  items?: Product[] | undefined;
}

export interface ProductVariant {
  id?: string;
  customProperties?: { [key: string]: any } | undefined;
  name?: string | undefined;
  productId?: string;
  sku?: string | undefined;
  externalId?: string | undefined;
  supplierId?: string;
  createdAt?: Date;
  billingFrequency?: BillingFrequency;
  period?: string | undefined;
  hash?: string | undefined;
}

export interface ProductVariantProductResponse {
  count?: number | undefined;
  items?: ProductVariant[] | undefined;
}

export interface Properties {
  createTenantProperties?: CreateTenantProperties;
  tenantId?: string | undefined;
}

export enum PropertyType {
  Boolean = 'Boolean',
  Byte = 'Byte',
  Int16 = 'Int16',
  Int32 = 'Int32',
  Int64 = 'Int64',
  Float = 'Float',
  Double = 'Double',
  Date = 'Date',
  DateTime = 'DateTime',
  Char = 'Char',
  String = 'String',
  Guid = 'Guid',
  Binary = 'Binary',
  Enum = 'Enum',
  Json = 'Json',
  List = 'List',
}

export interface Sku {
  name?: string | undefined;
  tier?: string | undefined;
}

export enum SortDirection {
  Ascending = 'Ascending',
  Descending = 'Descending',
}

export interface SortItem {
  property?: string | undefined;
  direction?: SortDirection;
}

export interface StartImportRequest {
  importId?: string;
  priceListId?: string;
}

export interface StringAzureAuthorizedRequest {
  authToken?: string | undefined;
  value?: string | undefined;
}

export interface SupplierPriceListItem extends PriceListItem {
  name?: string | undefined;
  businessPartnerId?: string;
}

export interface SupplierPriceListItemDataResult {
  entities?: SupplierPriceListItem[] | undefined;
  resultCount?: number | undefined;
}

export interface T {}

export interface TenantBusinessPartnerCreationRequest {
  name?: string | undefined;
  addressLine1?: string | undefined;
  addressLine2?: string | undefined;
  contactFirstName?: string | undefined;
  contactLastName?: string | undefined;
  contactPhone?: string | undefined;
  contactEmail?: string | undefined;
  domain?: string | undefined;
}

export interface TenantConfig {
  features?: string[] | undefined;
  googleMapsKey?: string | undefined;
}

export interface TenantCreationRequest {
  businessPartnerId?: string;
  clusterId?: string;
  displayName?: string | undefined;
  domain?: string | undefined;
  configurationPlanId?: string | undefined;
}

export interface TenantIntegrationRequest {
  integrationDisplayName?: string | undefined;
}

export interface TenantCspIntegrationRequest extends TenantIntegrationRequest {
  tenantId?: string;
  partnerName?: string | undefined;
  partnerDomain?: string | undefined;
}

export interface TenantResource {
  location?: string | undefined;
  sku?: Sku;
  properties?: Properties;
  id?: string | undefined;
  name?: string | undefined;
}

export interface TenantResponse {
  id?: string;
  businessPartnerId?: string;
  clusterName?: string | undefined;
  displayName?: string | undefined;
  domain?: string | undefined;
  tenantStatus?: TenantStatus;
  tenantStatusDisplayName?: string | undefined;
  configurationPlanName?: string | undefined;
}

export enum TenantStatus {
  Active = 'Active',
  Disabled = 'Disabled',
  NotConfigured = 'NotConfigured',
  ActionRequired = 'ActionRequired',
}

export interface V1IngressLoadBalancerIngress {
  hostname?: string | undefined;
  ip?: string | undefined;
  ports?: V1IngressPortStatus[] | undefined;
}

export interface V1IngressLoadBalancerStatus {
  ingress?: V1IngressLoadBalancerIngress[] | undefined;
}

export interface V1IngressPortStatus {
  error?: string | undefined;
  port?: number;
  protocol?: string | undefined;
}

export interface V1IngressStatus {
  loadBalancer?: V1IngressLoadBalancerStatus;
}

export interface V1ListMeta {
  continue?: string | undefined;
  remainingItemCount?: number | undefined;
  resourceVersion?: string | undefined;
  selfLink?: string | undefined;
}

export interface V1Status {
  readonly hasObject?: boolean;
  apiVersion?: string | undefined;
  code?: number | undefined;
  details?: V1StatusDetails;
  kind?: string | undefined;
  message?: string | undefined;
  metadata?: V1ListMeta;
  reason?: string | undefined;
  status?: string | undefined;
}

export interface V1StatusCause {
  field?: string | undefined;
  message?: string | undefined;
  reason?: string | undefined;
}

export interface V1StatusDetails {
  causes?: V1StatusCause[] | undefined;
  group?: string | undefined;
  kind?: string | undefined;
  name?: string | undefined;
  retryAfterSeconds?: number | undefined;
  uid?: string | undefined;
}

export interface ValidationResponse {
  isValid?: boolean;
  message?: string | undefined;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
